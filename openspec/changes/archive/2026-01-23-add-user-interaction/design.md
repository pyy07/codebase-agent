# Design: Agent 与用户交互机制

## Context

当前 Agent 使用 LangGraph 构建工作流，执行流程是：`plan -> execute_step -> decide -> (continue/synthesize)`。整个过程是单向的，Agent 无法在需要时暂停并请求用户输入。

## Goals

- Agent 可以在执行过程中主动请求用户输入额外信息
- 用户回复后，Agent 能够基于新信息继续分析
- 支持多次交互（Agent 可以多次请求用户输入）
- 保持现有功能的完全兼容性

## Non-Goals

- 不支持实时对话（不是聊天机器人）
- 不支持 Agent 主动发起新话题（只在分析过程中请求信息）
- 不支持用户主动中断 Agent 执行（用户只能回复询问）

## Decisions

### 1. 交互节点设计

**决策**：在 LangGraph 中添加 `request_user_input` 节点，作为 `decide` 节点的可选输出。

**理由**：
- 符合 LangGraph 的节点-边架构
- 可以自然地集成到现有工作流中
- 状态管理清晰（AgentState 保持不变）

**替代方案**：
- 使用工具调用方式：Agent 调用一个特殊的"请求用户输入"工具
  - **缺点**：工具调用通常期望立即返回结果，不适合异步等待用户输入

### 2. 状态管理

**决策**：使用内存字典存储暂停的会话状态（request_id -> AgentState），生产环境可扩展到 Redis。

**理由**：
- 简单直接，无需额外依赖
- 对于单实例部署足够使用
- 未来可以轻松迁移到 Redis

**会话状态包含**：
- `request_id`: 唯一请求标识
- `state`: AgentState 快照
- `timestamp`: 创建时间（用于超时清理）
- `sse_connection`: SSE 连接引用（用于继续发送事件）

### 3. 用户回复 API 设计

**决策**：使用 `POST /api/v1/analyze/reply` 端点，接收 `request_id` 和 `reply`。

**理由**：
- RESTful 设计，清晰明确
- 与现有的 `/api/v1/analyze` 端点保持一致
- 易于前端调用

**请求格式**：
```json
{
  "request_id": "uuid",
  "reply": "用户回复的文本"
}
```

### 4. SSE 事件设计

**决策**：新增 `user_input_request` 事件类型，包含：
- `request_id`: 唯一标识
- `question`: Agent 的询问内容
- `context`: 可选的上下文信息（说明为什么需要这个信息）

**理由**：
- 复用现有的 SSE 机制
- 前端已有完善的 SSE 处理逻辑
- 事件格式清晰，易于解析

### 5. 前端交互设计

**决策**：在消息流中显示 Agent 的询问，用户可以在同一消息块中回复。

**理由**：
- 保持对话的连续性
- 用户体验自然（类似聊天）
- 实现简单，无需额外的模态框

**UI 流程**：
1. Agent 发送 `user_input_request` 事件
2. 前端显示询问内容，并显示输入框
3. 用户输入并提交
4. 前端调用回复 API
5. Agent 继续执行，显示后续结果

## Risks / Trade-offs

### 风险 1: 会话状态丢失
- **风险**：如果服务重启，暂停的会话状态会丢失
- **缓解**：使用 Redis 持久化（可选），或提示用户重新开始

### 风险 2: 用户长时间不回复
- **风险**：Agent 执行状态占用内存
- **缓解**：实现会话超时机制（如 30 分钟），自动清理过期会话

### 风险 3: 多次交互导致上下文过长
- **风险**：多次用户回复可能导致 prompt 过长
- **缓解**：在 prompt 长度检查时考虑用户回复，必要时提前结束分析

### 权衡：同步 vs 异步
- **选择**：使用异步方式（SSE + API 回复）
- **权衡**：实现复杂度较高，但用户体验更好（无需轮询）

## Migration Plan

### Phase 1: 后端核心功能
1. 实现 `request_user_input` 节点
2. 添加 SSE 事件支持
3. 实现状态管理

### Phase 2: API 端点
1. 添加用户回复 API
2. 实现会话恢复逻辑

### Phase 3: 前端集成
1. 添加类型定义
2. 实现 SSE 事件处理
3. 创建交互组件

### Phase 4: 测试和优化
1. 编写测试
2. 优化用户体验
3. 文档更新

## Open Questions

1. **多次交互限制**：是否应该限制 Agent 请求用户输入的次数？（如最多 3 次）
   - **建议**：先不限制，根据实际使用情况再决定

2. **用户取消**：是否允许用户取消等待中的询问？
   - **建议**：Phase 1 不支持，后续版本可以考虑

3. **超时处理**：用户长时间不回复时，Agent 应该如何处理？
   - **建议**：超时后自动结束分析，返回基于已有信息的结论
